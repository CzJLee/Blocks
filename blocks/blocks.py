import functools
from typing import Iterable

import networkx as nx
import visualize

type Voxel = tuple[int, int, int]
"""An (x, y, z) coordinate representing a 1x1x1 unit cube of a piece."""

type Voxels = set[Voxel]
"""A set of voxels that represent a solid puzzle piece or space."""

class Piece:
    """Piece class."""

    def __init__(
        self,
        voxels: Iterable[Voxel],
        name: str = "Piece",
        canonicalize: bool = False,
        validate: bool = True,
    ):
        """
        Create a piece.

        Args:
            voxels: an iterable of (x, y, z) tuples indicating which unit voxels the piece occupies.
            name: name of the piece.
            canonicalize: Canonicalize the piece so that the piece's voxels are shifted so that the minimal x, y, z are 0.
            validate: Check that the piece is contiguous.
        """
        self.name = name
        self.voxels: Voxels = set(voxels)
        if canonicalize:
            self.canonicalize()

        if validate and not self.is_contiguous():
            raise ValueError("Piece is not contiguous.")

    def __len__(self):
        """Return the number of voxels in the piece."""
        return len(self.voxels)

    def is_contiguous(self):
        """Returns True of a piece is fully connected (6-connectivity), False otherwise."""
        G = nx.Graph()
        G.add_nodes_from(self.voxels)

        # 6-connectivity
        directions = [
            (1, 0, 0),
            (-1, 0, 0),
            (0, 1, 0),
            (0, -1, 0),
            (0, 0, 1),
            (0, 0, -1),
        ]

        # Draw edges between connected voxels.
        for x, y, z in self.voxels:
            for dx, dy, dz in directions:
                neighbor = (x + dx, y + dy, z + dz)
                if neighbor in self.voxels:
                    G.add_edge((x, y, z), neighbor)

        return nx.is_connected(G)

    def canonicalize(self):
        """Shift coords so that minimal x,y,z are all zero or non-negative."""
        if not self.voxels:
            return
        min_x = min(x for (x, _, _) in self.voxels)
        min_y = min(y for (_, y, _) in self.voxels)
        min_z = min(z for (_, _, z) in self.voxels)
        self.voxels = {(x - min_x, y - min_y, z - min_z) for (x, y, z) in self.voxels}

    def translate(self, dx: int, dy: int, dz: int) -> "Piece":
        """Return a new Piece shifted by (dx, dy, dz)."""
        new_coords = {(x + dx, y + dy, z + dz) for (x, y, z) in self.voxels}
        return Piece(new_coords, canonicalize=False, name=self.name)

    def rotate_x(self, canonicalize: bool = True) -> "Piece":
        """
        Rotate 90째 about the X-axis. That is, (x,y,z) -> (x, -z, y)
        (assuming right-hand rule, etc.). After rotation canonicalize.
        """
        new_coords = {(x, -z, y) for (x, y, z) in self.voxels}
        return Piece(new_coords, canonicalize=canonicalize, name=self.name)

    def rotate_y(self, canonicalize: bool = True) -> "Piece":
        """Rotate 90째 about Y axis: (x,y,z) -> (z, y, -x)"""
        new_coords = {(z, y, -x) for (x, y, z) in self.voxels}
        return Piece(new_coords, canonicalize=canonicalize, name=self.name)

    def rotate_z(self, canonicalize: bool = True) -> "Piece":
        """Rotate 90째 about Z axis: (x,y,z) -> (-y, x, z)"""
        new_coords = {(-y, x, z) for (x, y, z) in self.voxels}
        return Piece(new_coords, canonicalize=canonicalize, name=self.name)

    def all_rotations(self) -> set["Piece"]:
        """
        Return a set of all distinct orientations (rotations) of this piece
        under the group generated by 90째 rotations about X, Y, Z axes.
        """
        rotations: set[Piece] = set()
        # We'll generate by applying sequences of rotations.
        # Because there are only 24 possible orientations for cubes under rotations (no reflection),
        # this is finite and small.
        to_explore = [self]

        while to_explore:
            p = to_explore.pop()
            if p in rotations:
                continue
            rotations.add(p)
            # apply the three basic rotations
            for rp in (p.rotate_x(), p.rotate_y(), p.rotate_z()):
                if rp not in rotations:
                    to_explore.append(rp)
        return rotations

    @functools.cache
    def unique_rotations(self, canonicalize: bool = True) -> set["Piece"]:
        """
        Precompute all distinct rotations for this piece.
        Eliminates duplicates due to symmetry.
        """
        unique_rotations: set[Piece] = set()
        to_explore = [self]

        while to_explore:
            p = to_explore.pop()
            if p in unique_rotations:
                continue
            unique_rotations.add(p)
            # generate next rotations
            for rp in (
                p.rotate_x(canonicalize=canonicalize),
                p.rotate_y(canonicalize=canonicalize),
                p.rotate_z(canonicalize=canonicalize),
            ):
                if rp not in unique_rotations:
                    to_explore.append(rp)

        return unique_rotations

    def bounding_box(self) -> tuple[Voxel, Voxel]:
        """
        Returns ((min_x, min_y, min_z), (max_x, max_y, max_z)) for the piece.
        """
        xs = [x for (x, _, _) in self.voxels]
        ys = [y for (_, y, _) in self.voxels]
        zs = [z for (_, _, z) in self.voxels]
        return ((min(xs), min(ys), min(zs)), (max(xs), max(ys), max(zs)))

    def __eq__(self, other: object) -> bool:
        """Checks if pieces are exactly equal."""
        if not isinstance(other, Piece):
            return False
        return self.voxels == other.voxels

    def is_congruent(self, other: "Piece") -> bool:
        """
        Check if this piece is congruent to another piece,
        meaning they are equal up to rotation and translation.
        """
        if not isinstance(other, Piece):
            return TypeError("Cannot compare congruence between non-pieces.")

        # Canonicalize the pieces (translation-invariant)
        self_canonical = Piece(self.voxels, canonicalize=True)
        other_canonical = Piece(other.voxels, canonicalize=True)

        # If self (any rotation) matches other, return True
        return other_canonical in self_canonical.unique_rotations()

    def __hash__(self) -> int:
        # Hash based on frozenset of coords
        return hash(frozenset(self.voxels))

    def __str__(self) -> str:
        return f"{self.name}({sorted(self.voxels)})"

    def __repr__(self) -> str:
        return f"{self.__class__.__name__}({sorted(self.voxels)})"


class Space:
    def __init__(self, allowed_voxels: Voxels):
        """
        allowed_voxels: set of (x, y, z) tuples where pieces are allowed.
        Can represent any shape of space, not just a cuboid.
        """
        self.allowed_voxels = allowed_voxels
        self.occupied_voxels: Voxels = set()

    @classmethod
    def cuboid(cls, size_x: int, size_y: int, size_z: int) -> "Space":
        """Create a rectangular space of size_x * size_y * size_z"""
        voxels = {
            (x, y, z)
            for x in range(size_x)
            for y in range(size_y)
            for z in range(size_z)
        }
        return cls(voxels)

    def can_place(self, piece: Piece) -> bool:
        """Check if piece in its current position and orientation can fit into the space and does not overlap occupied voxels."""
        # This is done by ensuring that the voxel set does not overlap.

        # Check if the voxel pieces is a subset of the allowed voxels.
        can_fit_in_allowed_voxels = piece.voxels <= self.allowed_voxels

        # Check if the voxel pieces is not overlapping with the occupied voxels.
        does_not_overlap_occupied_voxels = piece.voxels.isdisjoint(self.occupied_voxels)

        return can_fit_in_allowed_voxels and does_not_overlap_occupied_voxels

    def place(self, piece: Piece, validate: bool = False):
        """Place a piece (mark voxels as occupied). Assumes can_place was True."""
        if validate:
            if not self.can_place(piece):
                raise ValueError("Cannot place piece in space.")
        self.occupied_voxels |= piece.voxels

    def remove(self, piece: Piece):
        """Remove a piece from space (for backtracking)."""
        self.occupied_voxels -= piece.voxels


class Solver:
    def __init__(self, space: Space, pieces: list[Piece]):
        self.space = space
        self.pieces = sorted(
            pieces, key=lambda x: len(x.unique_rotations()), reverse=True
        )
        self.solutions: list[list[Piece]] = []

    def legal_translations(self, piece: Piece) -> list[Piece]:
        """Generate all legal translations of a piece inside the space."""
        (min_px, min_py, min_pz), (max_px, max_py, max_pz) = piece.bounding_box()
        xs = [x for x, _, _ in self.space.allowed_voxels]
        ys = [y for _, y, _ in self.space.allowed_voxels]
        zs = [z for _, _, z in self.space.allowed_voxels]

        min_dx, max_dx = min(xs) - min_px, max(xs) - max_px
        min_dy, max_dy = min(ys) - min_py, max(ys) - max_py
        min_dz, max_dz = min(zs) - min_pz, max(zs) - max_pz

        translations = []
        for dx in range(min_dx, max_dx + 1):
            for dy in range(min_dy, max_dy + 1):
                for dz in range(min_dz, max_dz + 1):
                    candidate = piece.translate(dx, dy, dz)
                    if self.space.can_place(candidate):
                        translations.append(candidate)
        return translations

    def solve(self) -> list[list[Piece]]:
        if not self.pieces:
            # If given no pieces, return no solutions.
            return []

        # Lock the first piece rotation to reduce global rotational duplicates
        first_piece = self.pieces[0]
        remaining_pieces = self.pieces[1:]

        fixed_rotation = first_piece  # or first_piece.canonical_rotation()
        for candidate in self.legal_translations(fixed_rotation):
            # For the first piece, try placing all legal translations, and then continue recursive solve.
            if self.space.can_place(candidate):
                self.space.place(candidate)
                self._solve_recursive(remaining_pieces, [candidate])
                self.space.remove(candidate)

        return self.solutions

    def _solve_recursive(
        self, remaining_pieces: list[Piece], placed_pieces: list[Piece]
    ):
        if not remaining_pieces:
            # Solution found
            self.solutions.append(list(placed_pieces))
            return

        piece = remaining_pieces[0]
        next_remaining = remaining_pieces[1:]

        for rot in piece.unique_rotations(canonicalize=False):
            for candidate in self.legal_translations(rot):
                if self.space.can_place(candidate):
                    self.space.place(candidate)
                    placed_pieces.append(candidate)
                    self._solve_recursive(next_remaining, placed_pieces)
                    placed_pieces.pop()
                    self.space.remove(candidate)


if __name__ == "__main__":
    p1 = Piece(
        {(0, 0, 0), (0, 1, 0), (1, 0, 0), (1, 1, 0), (0, 0, 1), (0, 0, 2)},
        name="L_shape",
    )
    p2 = Piece(
        {(0, 0, 0), (1, 0, 0), (2, 0, 0), (2, 0, 1), (0, 1, 0), (0, 2, 0), (0, 2, 1)},
        name="V_shape",
    )
    p3 = Piece(
        {(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 0, 1), (2, 0, 0), (2, 1, 0), (2, 2, 0)},
        name="J_shape",
    )
    p4 = Piece({(0, 0, 0), (1, 0, 0), (0, 1, 0), (0, 1, 1), (0, 1, 2)}, name="S_shape")
    vegetable_basket = [p1, p2, p3, p4]

    p1 = Piece({(0, 0, 0), (1, 0, 0), (0, 1, 0)}, name="orange_L_piece")
    p2 = Piece(
        {
            (0, 0, 0),
            (0, 1, 0),
            (0, 2, 0),
            (1, 1, 0),
            (1, 2, 0),
            (2, 1, 0),
            (2, 2, 0),
            (0, 0, 1),
            (0, 1, 1),
            (0, 2, 1),
            (1, 1, 1),
            (1, 2, 1),
            (2, 1, 1),
            (2, 2, 1),
            (1, 3, 1),
            (1, 3, 2),
        },
        name="orange_block_piece",
    )
    p3 = Piece(
        {
            (0, 0, 0),
            (1, 0, 0),
            (2, 0, 0),
            (3, 0, 0),
            (3, 0, 1),
            (3, -1, 0),
            (3, -1, 1),
            (0, 0, 1),
            (0, 0, 2),
            (0, 1, 2),
            (0, 2, 2),
            (1, 2, 2),
        },
        name="orange_J_piece",
    )
    p4 = Piece(
        {
            (0, 0, 0),
            (1, 0, 0),
            (0, 1, 0),
            (1, 1, 0),
            (2, 1, 0),
            (0, 2, 0),
            (0, 0, 1),
            (0, 0, 2),
            (0, 0, 3),
            (0, 1, 3),
            (0, 2, 3),
            (1, 2, 3),
            (2, 2, 3),
            (3, 2, 3),
            (3, 2, 2),
            (3, 2, 1),
        },
        name="gray_logo",
    )
    p5 = Piece(
        {
            (0, 0, 0),
            (0, 1, 0),
            (0, 2, 0),
            (0, 2, 1),
            (1, 0, 0),
            (2, 0, 0),
            (3, 0, 0),
            (3, 1, 0),
            (3, 1, 1),
            (3, 1, 2),
            (2, 1, 2),
            (2, 1, 3),
            (1, 1, 3),
            (0, 1, 3),
            (0, 2, 3),
            (0, 3, 3),
            (0, 3, 2),
        },
        name="gray_signature",
    )
    roughhouse = [p1, p2, p3, p4, p5]

    solver = Solver(
        space=Space.cuboid(3, 3, 3),
        pieces=vegetable_basket,
    )
    solutions = solver.solve()

    print(f"Found {len(solutions)} solutions.")
    for sol in solutions:
        print(sol)

    visualize.plot_solutions(solutions)
